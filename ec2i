#!/bin/bash

set -euo pipefail

# TODO: usage stdout and exit 0 if -h
# TODO: $# checks

CONFIG="$HOME/.ec2i.json"

OURDIR=$(dirname $0)
OURNAME=$(basename $0)

# ----------------------------------------------------------------
usage() {
    echo "Usage: $OURNAME {command}" 1>&2
    cat 1>&2 <<EOF

Given a config file with mappings from epithets/nicknames to AWS EC2 parameters,
allows you to start, stop, ssh, etc. The config file encapsulates instance IDs
and AWS regions, and manages IP address and PEM paths, etc, so you don't have to
keystroke those out all the time.

Requires jq, mlr, and synctool.

Commands list:

$OURNAME list                 Show epithets and parameters
$OURNAME config               Show the config file with epithet-to-parameter mappings

$OURNAME start    {epithet}   Start the named instance
$OURNAME stop     {epithet}   Stop  the named instance
$OURNAME show     {epithet}   Show config-file parameters for the named instance
$OURNAME ssh      {epithet}   SSH into the named instance (does not auto-start it)

$OURNAME sshup    {epithet}   SSH into the named instance with auto-start and wait for ready

$OURNAME tags     {epithet}   Shows EC2 tags for the named instance
$OURNAME tag      {epithet} {key} {value} Sets an EC2 tag for the named instance

$OURNAME ip       {epithet}   Shows current IP-address assignment
$OURNAME state    {epithet}   Shows one-word EC2 state for the named instance
$OURNAME info     {epithet}   Shows full EC2 JSON info for the named instance

$OURNAME rel-from {epithet} {path}
$OURNAME rel-to   {epithet} {path}
$OURNAME rel-del  {epithet} {path}
$OURNAME pull-pwd {epithet}
$OURNAME push-pwd {epithet}
EOF
    exit 1
}

# ================================================================
main() {
    if [ $# -eq 0 ];then
        usage
    fi
    command="$1"
    shift

    # No instance name required
    if   [ "$command" = "list" ]; then
        list_instances
        exit 0
    fi
    if   [ "$command" = "config" ]; then
        show_config
        exit 0
    fi

    if [ $# -eq 0 ]; then
        echo "$OURNAME: need instance epithet from $CONFIG"
        usage
    fi
    epithet="$1"
    shift

    instance_id=$(epithet_to_instance_id $epithet)
    region=$(epithet_to_region $epithet)
    username=$(epithet_to_username $epithet)

    if [ "$command" = "start" ]; then
        start_instance $instance_id $region
    elif [ "$command" = "stop" ]; then
        stop_instance $instance_id $region
    elif [ "$command" = "show" ]; then
        show_instance $instance_id $region
    elif [ "$command" = "ssh" ]; then
        ssh_instance $username $instance_id $region

    elif [ "$command" = "sshup" ]; then
        start_wait_ssh_instance $username $instance_id $region

    elif [ "$command" = "ip" ]; then
        get_ip_address $instance_id $region
    elif [ "$command" = "state" ]; then
        show_instance_state $instance_id $region
    elif [ "$command" = "info" ]; then
        show_instance_info $instance_id $region
    elif [ "$command" = "tags" ]; then
        show_instance_tags $instance_id $region
    elif [ "$command" = "tag" ]; then
        if [ $# -ne 2 ]; then
            echo "$OURNAME: need epithet, key, and value." 1>&2
            exit 1
        fi
        key="$1"
        value="$2"
        set_instance_tag $instance_id $region $key $value

    elif [ "$command" = "rel-from" ]; then
        synctool_instance $username $instance_id $region "relfromremote" "$@"
    elif [ "$command" = "rel-to" ]; then
        synctool_instance $username $instance_id $region "reltoremote" "$@"
    elif [ "$command" = "rel-del" ]; then
        synctool_instance $username $instance_id $region "reldelremote" "$@"
    elif [ "$command" = "pull-pwd" ]; then
        synctool_instance $username $instance_id $region "pullpwd" "$@"
    elif [ "$command" = "push-pwd" ]; then
        synctool_instance $username $instance_id $region "pushpwd" "$@"
    else
        usage
    fi
}

# ================================================================
list_instances() {
    regions=$(jq -r .instances[].region $CONFIG | sort -u)
    for region in $regions; do
        AWS_DEFAULT_REGION=$region aws ec2 describe-instances
    done | mlr --j2p put -q -f $OURDIR/iis.mlr then sort -f State,Tags,Epithet
}

show_config() {
    jq '.pems[]' $CONFIG | mlr --j2p cat
    echo
    jq '.instances[]' $CONFIG | mlr --j2p cat
}

# ----------------------------------------------------------------
epithet_to_instance_id() {
    epithet="$1"
    instance_id=$(jq -r '.instances[] | select(.epithet=="'$epithet'") | .instance_id' $CONFIG)
    if [ "$instance_id" = "" ]; then
        echo "$OURNAME: could not find instance_id for epithet $epithet within config $CONFIG" 1>&2
        exit 1
    fi
    echo $instance_id
}

epithet_to_region() {
    epithet="$1"
    region=$(jq -r '.instances[] | select(.epithet=="'$epithet'") | .region' $CONFIG)
    if [ "$region" = "" ]; then
        echo "$OURNAME: could not find region for epithet $epithet within config $CONFIG" 1>&2
        exit 1
    fi
    echo $region
}

epithet_to_username() {
    epithet="$1"
    username=$(jq -r '.instances[] | select(.epithet=="'$epithet'") | .username' $CONFIG)
    if [ "$username" = "" ]; then
        echo "$OURNAME: could not find username for epithet $epithet within config $CONFIG" 1>&2
        exit 1
    fi
    echo $username
}

# ----------------------------------------------------------------
show_instance() {
    instance_id="$1"
    region="$2"
    AWS_DEFAULT_REGION=$region \
        aws ec2 describe-instances --query "Reservations[0].Instances[0]" --instance-ids $instance_id \
            | mlr --ijson --oxtab \
              cut -o -f KeyName,InstanceType,InstanceId,Architecture,LaunchTime,Placement.AvailabilityZone,State
}

start_instance() {
    instance_id="$1"
    region="$2"
    AWS_DEFAULT_REGION=$region aws ec2 start-instances --instance-ids $instance_id
}

stop_instance() {
    instance_id="$1"
    region="$2"
    AWS_DEFAULT_REGION=$region aws ec2 stop-instances --instance-ids $instance_id
}

ssh_with_pem() {
    username_and_ip_address="$1"
    pem_path="$2"
    echo
    echo ssh -i $pem_path $username_and_ip_address
    ssh -i $pem_path $username_and_ip_address
}

get_ip_address() {
    instance_id="$1"
    region="$2"
    AWS_DEFAULT_REGION=$region aws ec2 describe-instances --instance-ids $instance_id \
        | jq -r ".Reservations[0].Instances[0].PublicIpAddress"
}

get_pem_file() {
    region="$1"
    pem=$(jq -r '.pems[] | select(.region=="'$region'") | .pem' $CONFIG)
    if [ "$pem" = "null" ]; then
        echo "$OURNAME: could not find PEM for region $region within config $CONFIG"
        exit 1
    fi
    echo $pem
}

ssh_instance() {
    username="$1"
    instance_id="$2"
    region="$3"

    echo
    echo "username    $username"
    echo "instance_id $instance_id"
    echo "region      $region"

    ip_address=$(get_ip_address $instance_id $region)
    echo "ip_address  $ip_address"

    pem_file=$(get_pem_file $region)
    echo "pem_file    $pem_file"
    echo

    if [ "$ip_address" = "null" ]; then
        echo "Could not find IP address for $instance_id in $region. Is it running?"
    else
        ssh_with_pem $username@$ip_address $pem_file
    fi
}

start_wait_ssh_instance() {
    username="$1"
    instance_id="$2"
    region="$3"

    state=$(show_instance_state $instance_id $region)

    echo
    echo "username    $username"
    echo "instance_id $instance_id"
    echo "region      $region"
    echo "state       $state"

    if [ "$state" != "running" ]; then
        start_instance $instance_id $region
        n=1
        while true; do
            sleep 1
            n=$[n+1]
            if [ $n -gt 20 ]; then
                echo "$0: giving up on ssh to $instance_id in $region"
                exit 1
            fi
            state=$(show_instance_state $instance_id $region)
            echo "state       $state"
        done
    fi

    ssh_instance $username $instance_id $region
}

synctool_instance() {
    username="$1"
    instance_id="$2"
    region="$3"
    op="$4"
    shift; shift; shift; shift

    echo
    echo "instance_id $instance_id"
    echo "region      $region"

    ip_address=$(get_ip_address $instance_id $region)
    echo "ip_address  $ip_address"

    pem_file=$(get_pem_file $region)
    echo "pem_file    $pem_file"
    echo

    if [ "$ip_address" = "null" ]; then
        echo "Could not find IP address for $instance_id in $region. Is it running?" 1>&2
    else
        synctool -i $pem_file -r $username@$ip_address $op "$@"
    fi
}

# ----------------------------------------------------------------
show_instance_state() {
    instance_id="$1"
    region="$2"
    AWS_DEFAULT_REGION=$region aws ec2 describe-instances --instance-ids $instance_id \
        | jq -r ".Reservations[0].Instances[0].State.Name"
}

show_instance_info() {
    instance_id="$1"
    region="$2"
    AWS_DEFAULT_REGION=$region aws ec2 describe-instances --instance-ids $instance_id | jq .
}

show_instance_tags() {
    instance_id="$1"
    region="$2"
    AWS_DEFAULT_REGION=$region aws ec2 describe-tags --filters Name=resource-id,Values=$instance_id \
        | jq .Tags | mlr --j2p cat
}

set_instance_tag() {
    instance_id="$1"
    region="$2"
    name="$3"
    value="$4"
    AWS_DEFAULT_REGION=$region aws ec2 create-tags --resources $instance_id --tags Key="$name",Value="$value"
}

# ================================================================
main "$@"
